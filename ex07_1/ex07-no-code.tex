% Created 2018-04-15 Sun 01:33
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage{palatino}
\usepackage[top=1in, bottom=1.25in, left=1.25in, right=1.25in]{geometry}
\usepackage{setspace}
\setcounter{secnumdepth}{1}
\author{PRAVEEN KUMAR R}
\date{20/03/2017}
\title{Exercise 7: Matrices}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.5.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\linespread{1.2}
\begin{center}
\begin{tabular}{lr}
Assignment & 7\\
Reg No & 312217104114\\
Name & PRAVEEN KUMAR R\\
Grade & \\
Date & 20-03-2018\\
\end{tabular}
\end{center}

\section{Two-dimensional arrays}
\label{sec-1}
\begin{itemize}
\item Declare and initialize a $2 \times 3$ two-dimensional
array of integers.
\end{itemize}
\linespread{1}
\begin{itemize}
\item Initialize the 2d array.
\end{itemize}
\linespread{1.2}
\begin{itemize}
\item The size of first dimenstion is optional. Initialize the
2d array, leaving out the first dimension.
\end{itemize}
\linespread{1}
\linespread{1.2}
\begin{verbatim}
#include<stdio.h>
int main()
{
 int a[2][3]={{1,2,3},{4,5,6}},i,j;

 for(i=0;i<2;i++)
   {
    for(j=0;j<3;j++)
      printf("%d ",a[i][j]);
    printf("\n");
   }
int b[][3]={{1,2,3},{4,5,6},{7,8,9}};
int  n=3;
int  m=3;
printf("\n");
for(i=0;i<m;i++)
   {
    for(j=0;j<n;j++)
      printf("%d ",b[i][j]);
    printf("\n");
   }
return 0;
}
\end{verbatim}

\begin{center}
\begin{tabular}{rrr}
1 & 2 & 3\\
4 & 5 & 6\\
 &  & \\
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9\\
\end{tabular}
\end{center}

\section{Print a matrix on stdout}
\label{sec-2}
Define a function \texttt{mat\_print()} that prints a matrix. The
function is passed three parameters: matrix \texttt{a[M][N]}, and
two shape parameters \texttt{m} and \texttt{n} (number of rows and
number of columns). The size of the first dimension in
\texttt{a[M][N]} is optional. Test the function from \texttt{main()}.
\linespread{1}
\linespread{1.2}
\begin{verbatim}
#include<stdio.h>
void mat_print(int a[20][20],int m,int n)
{
 for(int i=0;i<m;i++)
  {
   for(int j=0;j<n;j++)
     printf("%d ",a[i][j]);
   printf("\n");
  }
}
int main()
{
 int a[20][20],n,m;
 scanf("%d%d",&m,&n);
 for(int i=0;i<m;i++)
   for(int j=0;j<n;j++)
    scanf("%d",&a[i][j]);
 mat_print(a,m,n);
return 0;
}
\end{verbatim}

\begin{center}
\begin{tabular}{rrrrr}
26 & -3 & 48 & 21 & 45\\
43 & 21 & 24 & 48 & 46\\
56 & 67 & 77 & 47 & 38\\
63 & 13 & -90 & 80 & 26\\
85 & 67 & 98 & 38 & 27\\
\end{tabular}
\end{center}

\section{Read a matrix from stdin}
\label{sec-3}
Define an input format for matrix. The first line
specifies the number of rows $m$ and columns $n$ of the
matrix. This is followed by $m$ lines. Each of these $m$
lines has $n$ numbers. After $m$ lines, the data for
another matrix may follow. For example, a $3 \times 4$
matrix and a $4 \times 3$ may be formatted in stdin as
follows. Test the function from \texttt{main()}.
\linespread{1}
\begin{verbatim}
3 4
10 20 30 40
50 60 70 80
90 100 110 120
4 3
1 1 1
2 2 2
3 3 3
4 4 4
\end{verbatim}
\linespread{1.2}
Define a function \texttt{mat\_read()} for reading a matrix in
this format. It has there results: a matrix and the shape
of the matrix. The shape variables are passed by
reference. Since matrix is a 2-d array, it is already
passed by reference. \texttt{a} is a constat pointer to an
integer.
\linespread{1}
\begin{verbatim}
#include<stdio.h>
 int mat_read (int a[50][50], int* m, int* n)
  {
  if(scanf("%d%d",m,n)!=EOF)
  {
 for(int i=0;i<*m;i++)
     for(int j=0;j<*n;j++)
       scanf("%d",&a[i][j]);
   return 1;
  }
 else
    return 0;
  }
void mat_print(int a[50][50],int m,int n)
{
   printf("%dx%d\n",m,n);
 for(int i=0;i<m;i++)
  {
   for(int j=0;j<n;j++)
     printf("%d ",a[i][j]);
   printf("\n");
  }
}
int main()
{
  int m,n ;int a[50][50];
  while(mat_read(a,&m,&n)!=0)
     {
	mat_print(a,m,n);
	printf("\n");
     }
}
\end{verbatim}

\begin{center}
\begin{tabular}{rrrr}
2x4 &  &  & \\
2 & 2 & 23 & 4\\
4 & 2 & 1 & 3\\
 &  &  & \\
5x3 &  &  & \\
24 & 46 & 373 & \\
73 & 73 & 736 & \\
287 & 27 & 82 & \\
3 & 73 & 65 & \\
35 & 390 & 56 & \\
 &  &  & \\
2x2 &  &  & \\
1 & 2 &  & \\
3 & 4 &  & \\
\end{tabular}
\end{center}

\linespread{1.2}
\section{Matrix addition}
\label{sec-4}

Write a function \texttt{mat\_add (a, b, c, m, n)} to add two
matrices \texttt{a} and \texttt{b} of shape \texttt{m x n}, and leave the
result in matrix \texttt{c}. Test this function and all the
subsequent functions from \texttt{main()}.
\linespread{1}
\linespread{1.2}
\subsection*{Alogorithm}
\label{sec-4-1}
\begin{verbatim}
def add(a,b,c,m,n):
   for i in range(m):
      for(j in range(n):
          c[i][j]=a[i][j]+b[i][j]
\end{verbatim}
\subsection*{Specification}
\label{sec-4-2}
\begin{enumerate}
\item \texttt{mat\_read()}:
\item input: a[][], a 2D integer array, rows, and coloumns.
\item output: \texttt{a[0:m][0:n]} with values in m rows and n columns.
\item \texttt{mat\_print()}:
\item input: \texttt{a[][]}, a 2D integer array, and dimensions of the matrix
\item output: none.
\item \texttt{mat\_add()}:
\item input: \texttt{a[][],b[][],c[][]}, 2D integer arrays of dimensions mxn
\item output: \texttt{c[0:m][0:n]} ,such that \texttt{c[i][j]=a[i][j]+b[i][j]}
\end{enumerate}
\subsection*{Program}
\label{sec-4-3}
\begin{verbatim}
#include<stdio.h>
void mat_read (int a[50][50], int m, int n)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      scanf("%d",&a[i][j]);
}
void mat_print(int a[50][50],int m,int n)
{
  for(int i=0;i<m;i++)
    {
      for(int j=0;j<n;j++)
	printf("%d ",a[i][j]);
      printf("\n");
    }
}
void mat_add(int a[50][50],int b[50][50],int c[50][50],int m,int n)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      c[i][j]=a[i][j]+b[i][j];
}
int main()
{
  int a[50][50],b[50][50],c[50][50],m,n;
  scanf("%d%d",&m,&n);
  mat_read(a,m,n);
  mat_read(b,m,n);
  mat_print(a,m,n);
  printf("\n");
  mat_print(b,m,n);
  printf("\n");
  mat_add(a,b,c,m,n);
  mat_print(c,m,n);
  return 0;
}
\end{verbatim}
\subsection*{Test}
\label{sec-4-4}
\subsubsection*{Input}
\label{sec-4-4-1}
\begin{verbatim}
 4 5
 1   2   3   4   5 
 6   7   8   9  10 
11  12  13  14  15 
16  17  18  19  20 

21  22  23  24  25 
26  27  28  29  30 
31  32  33  34  35 
36  37  38  39  40
\end{verbatim}

\subsubsection*{Output}
\label{sec-4-4-2}

\begin{center}
\begin{tabular}{rrrrr}
1 & 2 & 3 & 4 & 5\\
6 & 7 & 8 & 9 & 10\\
11 & 12 & 13 & 14 & 15\\
16 & 17 & 18 & 19 & 20\\
 &  &  &  & \\
21 & 22 & 23 & 24 & 25\\
26 & 27 & 28 & 29 & 30\\
31 & 32 & 33 & 34 & 35\\
36 & 37 & 38 & 39 & 40\\
 &  &  &  & \\
22 & 24 & 26 & 28 & 30\\
32 & 34 & 36 & 38 & 40\\
42 & 44 & 46 & 48 & 50\\
52 & 54 & 56 & 58 & 60\\
\end{tabular}
\end{center}

\section{Matrix copy}
\label{sec-5}
Define a function \texttt{mat\_copy (a, b, m, n)} that copies a
\texttt{m x n} matrix \texttt{a} to another matrix \texttt{b} of the same
shape. 
\linespread{1}
\linespread{1.2}
\subsection*{Alogrithm}
\label{sec-5-1}
\begin{verbatim}
def mat_copy(a,b,m,n):
  for i in range(m):
    for j in range(n):
      b[i][j]=a[i][j]
\end{verbatim}
\subsection*{Specification}
\label{sec-5-2}
\begin{enumerate}
\item \texttt{mat\_read()}:
\item input: a[][], a 2D integer array, rows, and coloumns.
\item output: \texttt{a[0:m][0:n]} with values in m rows and n columns.
\item \texttt{mat\_print()}:
\item input: \texttt{a[][]}, a 2D integer array, and dimensions of the matrix
\item output: none.
\item \texttt{mat\_copy()}:
\item input: \texttt{a[][],b[][]}, 2D integer arrays of dimensions mxn
\item output: \texttt{b[0:m][0:n]} ,such that \texttt{b[i][j]=a[i][j]}
\end{enumerate}
\subsection*{Progarm}
\label{sec-5-3}
\begin{verbatim}
#include<stdio.h>
void mat_read (int a[50][50], int m, int n)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      scanf("%d",&a[i][j]);
}
void mat_print(int a[50][50],int m,int n)
{
  for(int i=0;i<m;i++)
    {
      for(int j=0;j<n;j++)
	printf("%d ",a[i][j]);
      printf("\n");
    }
}
void mat_copy(int a[50][50],int b[50][50],int m,int n)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      b[i][j]=a[i][j];
}
int main()
{
  int a[50][50],b[50][50];
  int m,n;
  scanf("%d%d",&m,&n);
  mat_read(a,m,n);
  mat_read(b,m,n);
  printf("A :\n");
  mat_print(a,m,n);
  mat_copy(a,b,m,n);
  printf("\nB:\n");
  mat_print(b,m,n);
  return 0;
}
\end{verbatim}
\subsection*{Test}
\label{sec-5-4}
\subsubsection*{Input}
\label{sec-5-4-1}
\begin{verbatim}
 4 5
 1   2   3   4   5 
 6   7   8   9  10 
11  12  13  14  15 
16  17  18  19  20
\end{verbatim}

\subsubsection*{Output}
\label{sec-5-4-2}
\begin{center}
\begin{tabular}{rrrrr}
A & : &  &  & \\
1 & 2 & 3 & 4 & 5\\
6 & 7 & 8 & 9 & 10\\
11 & 12 & 13 & 14 & 15\\
16 & 17 & 18 & 19 & 20\\
 &  &  &  & \\
B: &  &  &  & \\
1 & 2 & 3 & 4 & 5\\
6 & 7 & 8 & 9 & 10\\
11 & 12 & 13 & 14 & 15\\
16 & 17 & 18 & 19 & 20\\
\end{tabular}
\end{center}

\section{Matrix scale}
\label{sec-6}
Write a function \texttt{mat\_scale (a, b, m, n, f)} that maps
every item of a \texttt{m x n} matrix \texttt{a} by multiplying it by it
by a factor \texttt{f} and assignes the result to a matrix \texttt{b}. 
\begin{verbatim}
mat_scale (a, f, b)
  for i := 0 to m-1
    for j := 0 to n-1
       b[j,i] := f * a[i,j]
\end{verbatim}
\linespread{1.2}
\subsection*{Alogrithm}
\label{sec-6-1}
\begin{verbatim}
def mat_copy(a,b,m,n,f):
  for i in range(m):
    for j in range(n):
      b[i][j]=f*a[i][j]
\end{verbatim}
\subsection*{Specification}
\label{sec-6-2}
\begin{enumerate}
\item \texttt{mat\_read()}:
\item input: a[][], a 2D integer array, rows, and coloumns.
\item output: \texttt{a[0:m][0:n]} with values in m rows and n columns.
\item \texttt{mat\_print()}:
\item input: \texttt{a[][]}, a 2D integer array, and dimensions of the matrix
\item output: none.
\item \texttt{mat\_scale()}:
\item input: \texttt{a[][],b[][]}, 2D integer arrays of dimensions mxn and scaling factor f
\item output: \texttt{b[0:m][0:n]} ,such that \texttt{b[i][j]=f*a[i][j]}
\end{enumerate}
\subsection*{Program}
\label{sec-6-3}
\begin{verbatim}
#include<stdio.h>
void mat_read (int a[50][50], int m, int n)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      scanf("%d",&a[i][j]);
}
void mat_print(int a[50][50],int m,int n)
{
  for(int i=0;i<m;i++)
    {
      for(int j=0;j<n;j++)
	printf("%d ",a[i][j]);
      printf("\n");
    }
}
void mat_scale(int a[50][50],int b[50][50],int m,int n,int f)
{
  for(int i=0;i<m;i++)
    for(int j=0;j<n;j++)
      b[i][j]=f*a[i][j];
}
int main()
{
  int a[50][50],b[50][50];
  int m,n,f;
  scanf("%d%d",&m,&n);
  mat_read(a,m,n);
  scanf("%d",&f);
  printf("A :\n");
  mat_print(a,m,n);
  mat_scale(a,b,m,n,f);
  printf("\nB:\n");
  mat_print(b,m,n);
  return 0;
}
\end{verbatim}
\subsection*{Test}
\label{sec-6-4}
\subsubsection*{Input}
\label{sec-6-4-1}
\begin{verbatim}
3 3
 9   8   7
 6   5   4
 3   2   1
6
\end{verbatim}

\subsubsection*{Output}
\label{sec-6-4-2}
\begin{center}
\begin{tabular}{rrr}
A & : & \\
9 & 8 & 7\\
6 & 5 & 4\\
3 & 2 & 1\\
 &  & \\
B: &  & \\
54 & 48 & 42\\
36 & 30 & 24\\
18 & 12 & 6\\
\end{tabular}
\end{center}

\section{Matrix transpose}
\label{sec-7}

Define a function \texttt{mat\_transpose (a, b, m, n)} that
assigns the transpose of a \texttt{m x n} matrix \texttt{a} to matrix
\texttt{b}. 

The algorithm for transposing a matrix is
\linespread{1}
\begin{verbatim}
mat_transpose (a, b)
  for i := 0 to m-1
    for j := 0 to n-1
       b[j,i] := a[i,j]
\end{verbatim}
\linespread{1.2}
It takes two parameters: an input matrix \texttt{a} and an output
matrix \texttt{b} in which the result is stored.  Thus, the
function intends to use \texttt{a} as a read parameter and \texttt{b} as
a write paratemeter.
\linespread{1}
\linespread{1.2}
However, since arrays are passed by reference, actually
both \texttt{a} and \texttt{b} are writeable. If someone calls the
function as
\begin{verbatim}
mat_transpose (a, a, m, n)
\end{verbatim}
in which \texttt{a} is read and written, the specification will
not be satisfied.  To avoid \texttt{a} being used for read and
write simultaneously, we have to use a temporary matrix to
store the transpose and, after the transpose is
constructed completely, copy it in the output array.

\linespread{1}
\linespread{1.2}
\subsection*{Alogrithm}
\label{sec-7-1}
\begin{verbatim}
def mat_copy(a,b,m,n):
  for i in range(m):
    for j in range(n):
      b[j[i]=a[i][j]
\end{verbatim}
\subsection*{Specification}
\label{sec-7-2}
\begin{enumerate}
\item \texttt{mat\_read()}:
\item input: a[][], a 2D integer array, rows, and coloumns.
\item output: \texttt{a[0:m][0:n]} with values in m rows and n columns.
\item \texttt{mat\_print()}:
\item input: \texttt{a[][]}, a 2D integer array, and dimensions of the matrix
\item output: none.
\item \texttt{mat\_transpose()}:
\item input: \texttt{a[][],b[][]}, 2D integer arrays of dimensions mxn
\item output: \texttt{b[0:m][0:n]} ,such that \texttt{b[j][i]=a[i][j]}
\end{enumerate}
\subsection*{Program}
\label{sec-7-3}
\begin{verbatim}
#include<stdio.h>
void mat_read (int a[50][50], int m, int n)
 {
 for(int i=0;i<m;i++)
     for(int j=0;j<n;j++)
       scanf("%d",&a[i][j]);
}
void mat_print(int a[50][50],int m,int n)
{
 for(int i=0;i<m;i++)
  {
   for(int j=0;j<n;j++)
     printf("%d ",a[i][j]);
   printf("\n");
  }
}
void mat_copy(int a[50][50],int b[50][50],int m,int n)
{
for(int i=0;i<m;i++)
     for(int j=0;j<n;j++)
      b[j][i]=a[i][j];
}
int main()
{
int a[50][50],b[50][50];
int m,n;
 scanf("%d%d",&m,&n);
mat_read(a,m,n);
mat_read(b,m,n);
printf("A :\n");
mat_print(a,m,n);
mat_copy(a,b,m,n);
printf("\nB:\n");
mat_print(b,n,m);
return 0;
}
\end{verbatim}
\subsection*{Test}
\label{sec-7-4}
\subsubsection*{Input}
\label{sec-7-4-1}
\begin{verbatim}
 4 5
 1   2   3   4   5 
 6   7   8   9  10 
11  12  13  14  15 
16  17  18  19  20
\end{verbatim}

\subsubsection*{Output}
\label{sec-7-4-2}
\begin{center}
\begin{tabular}{rrrrr}
A & : &  &  & \\
1 & 2 & 3 & 4 & 5\\
6 & 7 & 8 & 9 & 10\\
11 & 12 & 13 & 14 & 15\\
16 & 17 & 18 & 19 & 20\\
 &  &  &  & \\
B: &  &  &  & \\
1 & 6 & 11 & 16 & \\
2 & 7 & 12 & 17 & \\
3 & 8 & 13 & 18 & \\
4 & 9 & 14 & 19 & \\
5 & 10 & 15 & 20 & \\
\end{tabular}
\end{center}

\section{Matrix multiplication}
\label{sec-8}
Define a function \texttt{mat\_mul (a, b, c, m, n, p)} that
multplies an \texttt{m x n} matrix \texttt{a} and an \texttt{n x p} matrix \texttt{b}
and assigns the result to a \texttt{m x p} matrix \texttt{c}.

The algorithm for matrix multiplication is as follows.
\linespread{1}
\begin{verbatim}
matrix_add (a, b, c)
  for i := 0 to m-1
    for j := 0 to p-1
       // dot product of row i and column j
       c[i,j] := 0;
       for k := 0 to n-1:
          c[i,j] := a[i,k] + b [k,j]
\end{verbatim}
\linespread{1.2}
To avoid writing \texttt{a} or \texttt{b}, produce the result in a
temporary array \texttt{d}, and after the result is completely
produced, save it in \texttt{c}.
\linespread{1}
\subsection*{Alogrithm}
\label{sec-8-1}
\begin{verbatim}
def mat_copy(a,b,c,m,q,p):
  for i in range(m):
    for j in range(q):
        c[i][j]=0
        for k in range(p):
          c[i][j]+=a[i][k]*b[k][j]
\end{verbatim}
\subsection*{Specification}
\label{sec-8-2}
\begin{enumerate}
\item \texttt{mat\_read()}:
\item input: a[][], a 2D integer array, rows, and coloumns.
\item output: \texttt{a[0:m][0:n]} with values in m rows and n columns.
\item \texttt{mat\_print()}:
\item input: \texttt{a[][]}, a 2D integer array, and dimensions of the matrix
\item output: none.
\item \texttt{mat\_multiply()}:
\item input: \texttt{a[][],b[][],c[][]}, 2D integer arrays of dimensions mxn and pxq
\item output: \texttt{b[0:m][0:n]} ,such that c=axb.
\end{enumerate}
\subsection*{Program}
\label{sec-8-3}
\begin{verbatim}
#include<stdio.h>
void mat_read (int a[50][50], int m, int n)
 {
 for(int i=0;i<m;i++)
     for(int j=0;j<n;j++)
       scanf("%d",&a[i][j]);
}
void mat_print(int a[50][50],int m,int n)
{
 for(int i=0;i<m;i++)
  {
   for(int j=0;j<n;j++)
     printf("%d ",a[i][j]);
   printf("\n");
  }
}
void mat_mul(int a[50][50],int b[50][50],int c[50][50],int m,int q,int n)
 {
  for(int i=0;i<m;i++)
   {
       for(int j=0;j<q;j++)
	  {
	    c[i][j]=0;
	    for(int k=0;k<n;k++)
		c[i][j]+=a[i][k]*b[k][j];
	  } 
  }
}
int main()
{
 int a[50][50],b[50][50],c[50][50],m,n,p,q;
 scanf("%d%d",&m,&n);
 mat_read(a,m,n);
scanf("%d%d",&p,&q);
mat_read(b,p,q);
 mat_mul(a,b,c,m,q,n);
printf("A:\n");
mat_print(a,m,n);
printf("B:\n");
mat_print(b,p,q);
printf("C:\n");
mat_print(c,m,q);
return 0;
}
\end{verbatim}
\subsection*{Test}
\label{sec-8-4}
\subsubsection*{Input}
\label{sec-8-4-1}
\begin{verbatim}
   3 3
 1    2   3 
 4    5   6 
 7    8   9 
3 3        
 9    8   7 
 6    5   4 
 3    2   1
\end{verbatim}
\subsubsection*{Output}
\label{sec-8-4-2}
\begin{center}
\begin{tabular}{rrr}
A: &  & \\
1 & 2 & 3\\
4 & 5 & 6\\
7 & 8 & 9\\
B: &  & \\
9 & 8 & 7\\
6 & 5 & 4\\
3 & 2 & 1\\
C: &  & \\
30 & 24 & 18\\
84 & 69 & 54\\
138 & 114 & 90\\
\end{tabular}
\end{center}
% Emacs 24.5.1 (Org mode 8.2.10)
\end{document}
